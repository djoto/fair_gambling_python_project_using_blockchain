from gamblerNode import GamblerNode
import socket
import sys
import time
from random import randint
from datetime import datetime
from Crypto.PublicKey import RSA
from Crypto.Hash import SHA256
from Crypto.Signature.pkcs1_15 import PKCS115_SigScheme
import binascii
import os
import json
import ast
import math

host = str(sys.argv[1])
port = int(sys.argv[2])
        
while True:
    print("Do you want to generate new key pair? [y/n]\n(If answer is yes, program will create key in .pem file at location of your choice.\nIf answer is no, it means that you already have the key generated by this application and you have to load it.)")
    answer1 = input("Answer: ")
    if answer1 in ['y', 'Y', 'yes']:
        while True:
            print("\nInput directory path where key file will be located:")
            currTimestamp = int(datetime.timestamp(datetime.now()))
            keyPath = input("Path: ")
            try:
                f = open(keyPath+'/mykey_'+str(port)+'_'+str(currTimestamp)+'.pem', 'wb')
            except:
                print("Invalid path! Try again...")
                continue
            break
        key = RSA.generate(1024)
        f.write(key.exportKey('PEM'))
        f.close()
        print('Only PK:\n'+str(key.publickey().exportKey().decode())+'\n')
        break
    elif answer1 in ['n', 'N', 'no']:
        while True:
            print("\nInput correct name of .pem key file with entire path:")
            keyPath = input("Path: ") 
            try:
                f = open(keyPath, 'r')
                key = RSA.importKey(f.read())
            except:
                print("Invalid path or file! Try again...")
                continue
            break
        f.close() 
        print('Only PK:\n'+str(key.publickey().exportKey().decode())+'\n')
        break
    else:
        print("Incorrect answer! Try again...\n")
        continue
    
myProbability = None 
mySequenceChoice = None
requestedBlockchain = 0
requestedGambling = 0
onlyBlockchain = 0

while True:
    answer2 = input('\nDo you want to gamble or only download blockchain?\nEnter 0 for gambling\nEnter 1 for download blockchain\nYour answer: ')
    if answer2 in ['0', '1']:
        if int(answer2) == 0:
            requestedGambling = 1
            while True:
                probabilityChoice = input("\nBet probability options:\n2 for probability: 1/2\n4 for probability: 1/4\n8 for probability: 1/8\n16 for probability: 1/16\n32 for probability: 1/32\n64 for probability: 1/64\n128 for probability: 1/128\n256 for probability: 1/256\nEnter your choice: ")
                if (probabilityChoice in ['2', '4', '8', '16', '32', '64', '128', '256']):
                    myProbability = int(probabilityChoice)
                    break
                else:
                    print("Invalid input!")
                    continue
            while True:
                print("\nYou have to enter sequence with following number of ones or zeros: "+str(int(math.log(myProbability, 2))))
                mySequence = input("Enter your sequence: ")
                if len(mySequence) != int(math.log(myProbability, 2)):
                    print("Invalid input length!")
                    continue
                invalid = False
                for s in mySequence:
                    if (s not in ['0', '1']):
                        invalid = True
                        break
                if invalid:
                    print("Invalid sequence input!")
                    continue
                print("You predict that last "+str(int(math.log(myProbability, 2)))+" bit(s) in hash of block with your transaction in binary representation will be "+mySequence)
                mySequenceChoice = mySequence
                break
            while True:
                checkChoice = input("\nDo you want to download blockchain after game to check if you are winner or loser? [y/n]\nYour answer: ")
                if checkChoice in ['y', 'Y', 'yes']:
                    print("Blockchain file will be located in directory "+os.getcwd()+".")
                    requestedBlockchain = 1
                    break
                elif checkChoice in ['n', 'N', 'no']:
                    requestedBlockchain = 0
                    break
                else:
                    print("Incorrect answer! Try again...")
                    continue
            break
        elif int(answer2) == 1:
            onlyBlockchain = 1
            break
    else:
        print("Invalid input! Try again ...")
        continue

myKeyPair = key
myPublicKey = key.publickey()
pkHash = SHA256.new(myPublicKey.exportKey()).hexdigest()
myID = 'gambler:'+str(pkHash)
myGamblerNode = GamblerNode(host, port, myID)
myGamblerNode.start()


#if myGamblerNode.time_for_wait_connection():
print('waiting for connection ...')
while myGamblerNode.time_for_wait_connection():
    #print('waiting for connection ...')
    time.sleep(1)
    continue
firstTimestamp = datetime.timestamp(datetime.now()) % 120
myGamblerNode.join_p2p()

print('\nConnected validators:')
for i in myGamblerNode.peers_validators():
    print(str(i.id))
print('\n')

try:
    if requestedGambling:
        time.sleep(1)
        if (not myGamblerNode.time_for_listen_bets()):
            print('waiting to send bet ...')
        while (not myGamblerNode.time_for_listen_bets()):
            #print('waiting to send bet ...')
            time.sleep(1)
            continue
        myBet = myGamblerNode.make_bet(str(myProbability), mySequenceChoice, myKeyPair)
        myGamblerNode.send_bet_to_peers(myBet)
        time.sleep(2)
        if requestedBlockchain:
            print('waiting for blockchain ...')
            time.sleep(float(120) - firstTimestamp + 2)
            myGamblerNode.check_connected_validators()
            for i in myGamblerNode.peers_validators():
                myGamblerNode.send_to_node(i, 'sendBlockchainHash')
                time.sleep(0.3)
            time.sleep(5)
            for n in myGamblerNode.peers_validators():
                myGamblerNode.disconnect_with_node(n)
            print("\nChecking bet:")
            myGamblerNode.check_last_block(myPublicKey.exportKey().decode())
            myGamblerNode.stop()
            time.sleep(2)
            sys.exit(0)
        else:
            for n in myGamblerNode.peers_validators():
                myGamblerNode.disconnect_with_node(n)
            myGamblerNode.stop()
            time.sleep(2)
            sys.exit(0)
    elif onlyBlockchain:
        for i in myGamblerNode.peers_validators():
            myGamblerNode.send_to_node(i, 'sendBlockchainHash')
            time.sleep(0.3)
        time.sleep(5)
        for n in myGamblerNode.peers_validators():
            myGamblerNode.disconnect_with_node(n)
        print("\nChecking bets ...")        
        myGamblerNode.check_all_my_bets(myPublicKey.exportKey().decode())
        print('\n')
        myGamblerNode.stop()
        time.sleep(2)
        sys.exit(0)
except:
    myGamblerNode.stop()
    sys.exit(1)
