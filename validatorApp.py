from validatorNode import ValidatorNode
import socket
import sys
import time
from random import randint
from datetime import datetime
from Crypto.PublicKey import RSA
from Crypto.Hash import SHA256
from Crypto.Signature.pkcs1_15 import PKCS115_SigScheme
import binascii
import os
import json
import ast

host = str(sys.argv[1])
port = int(sys.argv[2])

while True:
    print("Do you want to generate new key pair? [y/n]\n(If answer is yes, program will create key in .pem file at location of your choice.\nIf answer is no, it means that you already have the key generated by this application and you have to load it.)")
    answer1 = input("Answer: ")
    if answer1 in ['y', 'Y', 'yes']:
        while True:
            print("\nInput directory path where key file will be located:")
            currTimestamp = int(datetime.timestamp(datetime.now()))
            keyPath = input("Path: ")
            try:
                f = open(keyPath+'/mykey_'+str(port)+'_'+str(currTimestamp)+'.pem', 'wb')
            except:
                print("Invalid path! Try again...")
                continue
            break
        key = RSA.generate(1024)
        f.write(key.exportKey('PEM'))
        f.close()
        print('Only PK:\n'+str(key.publickey().exportKey().decode())+'\n')
        break
    elif answer1 in ['n', 'N', 'no']:
        while True:
            print("\nInput correct name of .pem key file with entire path:")
            keyPath = input("Path: ") 
            try:
                f = open(keyPath, 'r')
                key = RSA.importKey(f.read())
            except:
                print("Invalid path or file! Try again...")
                continue
            break
        f.close() 
        print('Only PK:\n'+str(key.publickey().exportKey().decode())+'\n')
        break
    else:
        print("Incorrect answer! Try again...\n")
        continue
    


myKeyPair = key
myPublicKey = key.publickey()
pkHash = SHA256.new(myPublicKey.exportKey()).hexdigest()
myID = 'validator:'+str(pkHash)
myValidatorNode = ValidatorNode(host, port, myID)
myValidatorNode.start()

#if myValidatorNode.time_for_wait_connection():
print('waiting for connection ...')
while myValidatorNode.time_for_wait_connection():
    #print('waiting for connection ...')
    time.sleep(1)
    continue

myValidatorNode.join_p2p()

print('\nConnected validators:')
for i in myValidatorNode.peers_validators():
    print(str(i.port)+' - '+str(i.id))
#print('\n')


try:

    for i in myValidatorNode.peers_validators():
        myValidatorNode.send_to_node(i, 'sendBlockchainHash')
        time.sleep(0.3)
    time.sleep(2)


    while True:
        time.sleep(1)
        if myValidatorNode.time_for_listen_bets():
            print('listening for bets ...')
        while myValidatorNode.time_for_listen_bets():
            myValidatorNode.addedBlock = 0
            #print('listening for bets ...')
            time.sleep(1)
            continue
        #print('\n\n'+str(myValidatorNode.receivedBets)+'\n\n')
        myValidatorNode.check_connected_validators()
        myBlock = myValidatorNode.make_block(myKeyPair)
        myValidatorNode.send_block_to_peers(myBlock)
        if myValidatorNode.time_for_listen_blocks():
            print('listening for blocks ...')
        while myValidatorNode.time_for_listen_blocks():
            #print('listening for blocks ...')
            time.sleep(1)
            continue
        time.sleep(2)
        myValidatorNode.add_block_to_blockchain()
        
        continue

except:
    sys.exit(1)
